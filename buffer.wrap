-- vim: ft=wrap:
require "wrap"
include "term.h"
include "buffer.h"

class 'Buffer' (boxed)

method 'new' [[
	guint size = luaL_optint(L, 1, 1024);
	Buffer **b = pushBuffer(L);
	*b = buffer_new(size);
	return 1;
]] 

method 'set_histsize' [[
	Buffer *b = checkBuffer(L, 1);
	guint size = luaL_checkinteger(L, 2);
	buffer_set_histsize(b, size);
	return 0;
]]

method 'get_histsize' [[
	Buffer *b = checkBuffer(L, 1);
	lua_pushinteger(L, buffer_get_histsize(b));
	return 1;
]] 

method 'render' [[
	Buffer *b = checkBuffer(L, 1);
	buffer_render(b);
	return 0;
]]

method 'print' [[
	Buffer *b = checkBuffer(L, 1);
	const char *s = luaL_checkstring(L, 2);
	buffer_print(b, s);
	return 0;
]] 

method 'scroll' [[
	Buffer *b = checkBuffer(L, 1);
	int i = luaL_checkinteger(L, 2);
	buffer_scroll(b, i);
	return 0;
]]

method 'scroll_to' [[
	Buffer *b = checkBuffer(L, 1);
	int i = luaL_checkinteger(L, 2);
	buffer_scroll_to(b, i);
	return 0;
]]

-- Formats {{{1
method 'format' [[
	const char *input = luaL_checkstring(L, 1);
	GString *out = g_string_sized_new(strlen(input));
	const gchar *p = input;

	while (1) {
		const gchar *oldp = p;
		gchar *nextesc = strchr(p, '%');
		if (!nextesc) {
			g_string_append(out, p);
			// XXX: Maybe use lua_pushlstring?
			lua_pushstring(L, out->str);
			g_string_free(out, TRUE);
			return 1;
		}
		g_string_append_len(out, p, nextesc - p);
		switch (*(nextesc + 1)) {
			case '%':
				g_string_append_c(out, '%');
				p = nextesc + 2;
				break;
			case '|':
				g_string_append(out, BUFFER_INDENT_MARK_UTF);
				p = nextesc + 2;
				break;
			case '1' ... '9':
				{
					lua_rawgeti(L, 2, *(nextesc + 1) - '0');
					const char *s = lua_tostring(L, -1);
					if (s != NULL)
						g_string_append(out, s);
					p = nextesc + 2;
					lua_pop(L, 1);
					break;
				}
			case '{':
				{
					gchar *start = nextesc + 2;
					gchar *end = strchr(start, '}');
					if (end) {
						gchar name[end - start + 1];
						memcpy(name, start, sizeof name - 1);
						name[sizeof name - 1] = '\0';
						g_string_append(out, term_color_to_utf8(name));
						p = end + 1;
						break;
					} else { goto unknown_esc; }
				}
			default:
unknown_esc:
				g_string_append_c(out, *nextesc);
				p = nextesc + 1;
				break;
		}
		g_assert(p > oldp);
	}
	g_assert_not_reached();
]]

method 'format_escape' [[
	const char *input = luaL_checkstring(L, 1);
	GString *out = g_string_sized_new(strlen(input));

	const gchar *p = input;
	while (1) {
		gchar *nextesc = strchr(p, '%');
		if (!nextesc) {
			g_string_append(out, p);
			lua_pushstring(L, out->str);
			g_string_free(out, TRUE);
			return 1;
		}
		g_string_append_len(out, p, nextesc - p);
		g_string_append(out, "%%");
		p = nextesc + 1;
	}
	g_assert_not_reached();
]]
-- }}}

meta '__gc' [[
	Buffer *b = toBuffer(L, 1);
	buffer_free(b);
  	return 0;
]]

meta '__tostring' (default)

finish ()
